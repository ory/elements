// Copyright Â© 2024 Ory Corp
// SPDX-License-Identifier: Apache-2.0

import {
  AuthenticatorAssuranceLevel,
  FlowType,
  isUiNodeInputAttributes,
  OAuth2ConsentRequest,
  Session,
  UiContainer,
  UiNodeGroupEnum,
} from "@ory/client-fetch"
import { defineMessages, useIntl } from "react-intl"
import { FormState } from "../../../context"
import { uiTextToFormattedMessage } from "../../../util"
import { kratosMessages } from "../../../util/i18n/generated/kratosMessages"
import { resolveLabel } from "../../../util/nodes"
import { findNode } from "../../../util/ui"

function joinWithCommaOr(list: string[], orText = "or"): string {
  if (list.length === 0) {
    return "."
  } else if (list.length === 1) {
    return list[0]
  } else {
    const last = list.pop()
    return `${list.join(", ")} ${orText} ${last}`
  }
}

export type CardHeaderTextOptions =
  | {
      flowType: FlowType.Login
      flow: {
        refresh?: boolean
        requested_aal?: AuthenticatorAssuranceLevel
      }
      formState?: FormState
    }
  | {
      flowType: FlowType.Registration
      formState?: FormState
    }
  | {
      flowType: FlowType.OAuth2Consent
      flow: {
        consent_request: OAuth2ConsentRequest
        session: Session
      }
    }
  | {
      flowType:
        | FlowType.Error
        | FlowType.Verification
        | FlowType.Recovery
        | FlowType.Settings
    }

const loginSubtitles = defineMessages<string>({
  [UiNodeGroupEnum.Code]: {
    id: "login.code.subtitle",
    defaultMessage: "A verification code will be sent by email",
  },
  [UiNodeGroupEnum.Webauthn]: {
    id: "login.webauthn.subtitle",
    defaultMessage: "Please prepare your WebAuthN device",
  },
  [UiNodeGroupEnum.Totp]: {
    id: "login.totp.subtitle",
    defaultMessage: "Please enter the code generated by your Authenticator App",
  },
  [UiNodeGroupEnum.LookupSecret]: {
    id: "login.lookup_secret.subtitle",
    defaultMessage: "Please enter one of your 8-digit backup recovery codes",
  },
})

/**
 * Constructs a title and a description for the card header.
 *
 * The title is a title suitable for the current flow, e.g. "Sign in" or "Update your account".
 *
 * The description for a login & registration flow, is a collection of the labels of the input fields.
 * For example, if the user has a password and an email address, the description will be "Sign in with your email and password".
 * And for registration, the listed options depend on the project configuration.
 *
 * For verification, recovery and settings flows, the description is a generic one, e.g. "Enter the email address associated with your account to verify it".
 *
 *
 * @param nodes - the UI nodes of the current flow
 * @param opts - can be a flow object, only needed for the refresh login flow
 * @returns a title and a description for the card header
 */
export function useCardHeaderText(
  container: UiContainer,
  opts: CardHeaderTextOptions,
): { title: string; description: string; messageId?: string } {
  const nodes = container.nodes
  const intl = useIntl()
  switch (opts.flowType) {
    case FlowType.Recovery: {
      const recoveryV2Message = container.messages?.find((m) =>
        [1060006, 1060005, 1060004].includes(m.id),
      )

      if (recoveryV2Message) {
        return {
          title: intl.formatMessage({
            id: "recovery.title",
            defaultMessage: "Recover your account",
          }),
          description: uiTextToFormattedMessage(recoveryV2Message, intl),
          messageId: recoveryV2Message.id + "",
        }
      } else if (
        nodes.find(
          (node) =>
            "name" in node.attributes && node.attributes.name === "code",
        )
      ) {
        return {
          title: intl.formatMessage({
            id: "recovery.title",
            defaultMessage: "Recover your account",
          }),
          description: intl.formatMessage(kratosMessages[1060003]),
          messageId: "1060003",
        }
      }
      return {
        title: intl.formatMessage({
          id: "recovery.title",
          defaultMessage: "Recover your account",
        }),
        description: intl.formatMessage({
          id: "recovery.subtitle",
          defaultMessage:
            "Enter the identifier associated with your account to receive a one-time access code",
        }),
      }
    }
    case FlowType.Settings:
      return {
        title: intl.formatMessage({
          id: "settings.title",
          defaultMessage: "Account Settings",
        }),
        description: intl.formatMessage({
          id: "settings.subtitle",
          defaultMessage: "Update your account settings",
        }),
      }
    case FlowType.Verification:
      if (
        nodes.find(
          (node) =>
            "name" in node.attributes && node.attributes.name === "code",
        )
      ) {
        return {
          title: intl.formatMessage({
            id: "verification.title",
            defaultMessage: "Verify your account",
          }),
          description: intl.formatMessage(kratosMessages[1080003]),
          messageId: "1080003",
        }
      }
      return {
        title: intl.formatMessage({
          id: "verification.title",
          defaultMessage: "Verify your account",
        }),
        description: intl.formatMessage({
          id: "verification.subtitle",
          defaultMessage:
            "Enter the email address associated with your account to verify it",
        }),
      }
    case FlowType.Login: {
      // account linking
      const accountLinkingMessage = container.messages?.find(
        (m) => m.id === 1010016,
      )
      if (accountLinkingMessage) {
        return {
          title: intl.formatMessage({
            id: "account-linking.title",
            defaultMessage: "Link account",
          }),
          description: intl.formatMessage(
            kratosMessages[1010016],
            accountLinkingMessage.context as Record<string, string>,
          ),
          messageId: "1010016",
        }
      }
    }
  }

  const parts = []

  if (nodes.find((node) => node.group === "password")) {
    switch (opts.flowType) {
      case FlowType.Registration:
        parts.push(
          intl.formatMessage(
            {
              id: "card.header.parts.password.registration",
              defaultMessage: "your {identifierLabel} and a password",
            },
            // TODO: make this generic for other labels
            { identifierLabel: "email" },
          ),
        )
        break
      default:
        parts.push(
          intl.formatMessage(
            {
              id: "card.header.parts.password.login",
              defaultMessage: "your {identifierLabel} and password",
            },
            // TODO: make this generic for other labels
            { identifierLabel: "email" },
          ),
        )
    }
  }

  if (nodes.find((node) => node.group === "oidc" || node.group === "saml")) {
    parts.push(
      intl.formatMessage({
        id: "card.header.parts.oidc",
        defaultMessage: "a social provider",
      }),
    )
  }

  if (nodes.find((node) => node.group === "code")) {
    parts.push(
      intl.formatMessage({
        id: "card.header.parts.code",
        defaultMessage: "a one-time code",
      }),
    )
  }

  if (nodes.find((node) => node.group === "totp")) {
    parts.push(
      intl.formatMessage({
        id: "card.header.parts.totp",
        defaultMessage: "your authenticator app",
      }),
    )
  }

  if (nodes.find((node) => node.group === "lookup_secret")) {
    parts.push(
      intl.formatMessage({
        id: "card.header.parts.lookup_secret",
        defaultMessage: "a backup recovery code",
      }),
    )
  }

  if (nodes.find((node) => node.group === "passkey")) {
    parts.push(
      intl.formatMessage({
        id: "card.header.parts.passkey",
        defaultMessage: "a Passkey",
      }),
    )
  }

  if (nodes.find((node) => node.group === "webauthn")) {
    parts.push(
      intl.formatMessage({
        id: "card.header.parts.webauthn",
        defaultMessage: "a security key",
      }),
    )
  }

  if (nodes.find((node) => node.group === "identifier_first")) {
    const identifier = nodes.find(
      (node) =>
        isUiNodeInputAttributes(node.attributes) &&
        node.attributes.name.startsWith("identifier") &&
        node.attributes.type !== "hidden",
    )

    if (identifier) {
      parts.push(
        intl.formatMessage(
          {
            id: "card.header.parts.identifier-first",
            defaultMessage: "your {identifierLabel}",
          },
          {
            identifierLabel:
              identifier.meta.label &&
              resolveLabel(identifier.meta.label, intl),
          },
        ),
      )
    }
  }

  if (nodes.some((node) => node.group === "profile")) {
    const identifier = nodes.find(
      (node) =>
        isUiNodeInputAttributes(node.attributes) &&
        node.attributes.name.startsWith("traits.") &&
        node.attributes.type !== "hidden",
    )

    if (identifier) {
      parts.push(
        intl.formatMessage(
          {
            id: "card.header.parts.identifier-first",
            defaultMessage: "your {identifierLabel}",
          },
          {
            identifierLabel:
              identifier.meta.label &&
              resolveLabel(identifier.meta.label, intl),
          },
        ),
      )
    }
  }

  switch (opts.flowType) {
    case FlowType.Login: {
      const codeMethodNode = findNode(container.nodes, {
        node_type: "input",
        group: "code",
        name: "code",
        type: "text",
      })
      const codeSent =
        codeMethodNode &&
        opts.formState?.current === "method_active" &&
        opts.formState?.method === "code"

      const stringifiedParts = joinWithCommaOr(
        parts,
        intl.formatMessage({ id: "misc.or", defaultMessage: "or" }),
      )
      if (opts.flow.refresh) {
        const description = codeSent
          ? intl.formatMessage(kratosMessages[1010014], {
              parts: stringifiedParts,
            })
          : intl.formatMessage(
              {
                id: "login.subtitle-refresh",
                defaultMessage: "Confirm your identity with {parts}",
              },
              {
                parts: stringifiedParts,
              },
            )
        return {
          title: intl.formatMessage({
            id: "login.title-refresh",
            defaultMessage: "Reauthenticate",
          }),
          description,
        }
      } else if (opts.flow.requested_aal === "aal2") {
        const description = codeSent
          ? intl.formatMessage(kratosMessages[1010014])
          : opts.formState?.current === "method_active"
            ? intl.formatMessage(loginSubtitles[opts.formState.method])
            : intl.formatMessage({
                id: "login.subtitle-aal2",
                defaultMessage:
                  "Choose a way to complete your second factor authentication",
              })
        return {
          title: intl.formatMessage({
            id: "login.title-aal2",
            defaultMessage: "Second factor authentication",
          }),
          description,
        }
      }
      const description =
        parts.length > 0
          ? codeSent
            ? intl.formatMessage(kratosMessages[1010014])
            : intl.formatMessage(
                {
                  id: "login.subtitle",
                  defaultMessage: "Sign in with {parts}",
                },
                {
                  parts: stringifiedParts,
                },
              )
          : ""
      return {
        title: intl.formatMessage({
          id: "login.title",
          defaultMessage: "Sign in",
        }),
        description,
      }
    }
    case FlowType.Registration: {
      const codeMethodNode = findNode(container.nodes, {
        node_type: "input",
        group: "code",
        name: "code",
        type: "text",
      })
      const codeSent =
        codeMethodNode &&
        opts.formState?.current === "method_active" &&
        opts.formState?.method === "code"

      return {
        title: intl.formatMessage({
          id: "registration.title",
          defaultMessage: "Register an account",
        }),
        description: codeSent
          ? intl.formatMessage(kratosMessages[1040005])
          : parts.length > 0
            ? intl.formatMessage(
                {
                  id: "registration.subtitle",
                  defaultMessage: "Sign up with {parts}",
                },
                {
                  parts: joinWithCommaOr(
                    parts,
                    intl.formatMessage({ id: "misc.or", defaultMessage: "or" }),
                  ),
                },
              )
            : "",
      }
    }
    case FlowType.OAuth2Consent:
      return {
        title: intl.formatMessage(
          {
            id: "consent.title",
            defaultMessage: "Authorize {party}",
          },
          {
            party: opts.flow.consent_request.client?.client_name,
          },
        ),
        description: intl.formatMessage(
          {
            id: "consent.subtitle",
            defaultMessage:
              "A third party application wants to access information associated with your account {identifier}.",
          },
          {
            identifier: (opts.flow.session.identity?.traits.email ??
              "") as string,
          },
        ),
      }
  }

  // TODO: This should not happen, as the switch is exhaustive, but typescript doesn't think so
  return {
    title: "Error",
    description: "An error occurred",
  }
}
